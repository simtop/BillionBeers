plugins {
    alias(libs.plugins.compose.compiler)
    alias(libs.plugins.com.google.devtools.ksp)
}
androidModule(true)

apply plugin: 'androidx.navigation.safeargs'

android {
    dynamicFeatures = [':feature:beerdetail']
    namespace 'com.simtop.billionbeers'

    // Fixing R8 problems
    packagingOptions {
        exclude 'META-INF/versions/9/module-info.class'
        exclude 'a/a.class'
        exclude 'a/b.class'
    }
}

dependencies {
    implementation libs.navigationFragmentKtx
    implementation libs.navigationUi
    implementation project(":beerdomain")
    implementation project(":feature:beerslist")
    implementation project(":core")
    implementation project(":navigation")
    implementation project(":beer_data")
    implementation project(":beer_database")
    implementation project(":beer_network")
    implementation project(":presentation_utils")

    implementation libs.navigationDynamicFeaturesFragment

    implementation libs.androidPlayCore
    implementation libs.androidPlayCoreKtx

    testImplementation libs.striktCore

    androidTestImplementation libs.striktCore

    //TODO: move to another module when we create the test module
    implementation libs.junit
    implementation libs.coroutinesTest
}

// TODO: extract into a gradle plugin shows duplicate dependencies
// TODO: run ./gradlew :app:releasePrintDuplicateClasses
// TODO: needed to fix R8 problem
import com.android.build.api.artifact.ScopedArtifact
import com.android.build.api.variant.ScopedArtifacts
import java.util.zip.ZipEntry
import java.util.zip.ZipFile

abstract class PrintClassesJars extends DefaultTask {

    @InputFiles
    abstract ListProperty<RegularFile> getAllJars()

    @InputFiles
    abstract ListProperty<Directory> getAllDirectories()

    @TaskAction
    void findDuplicateClasses() {
        def classToJarMap = [:].withDefault { [] }

        def jarToModuleMap = buildJarToModuleMap()

        getAllJars().get().forEach { file ->
            try (ZipFile zipFile = new ZipFile(file.asFile)) {
                Enumeration<? extends ZipEntry> entries = zipFile.entries()
                while (entries.hasMoreElements()) {
                    ZipEntry entry = entries.nextElement()
                    if (entry.getName().endsWith(".class")) {
                        classToJarMap[entry.getName()] << file.asFile
                    }
                }
            }
        }

        def duplicates = classToJarMap.findAll { it.value.size() > 1 }

        if (duplicates) {
            println "⚠️ Found duplicate classes:"
            duplicates.each { className, jars ->
                println " - $className in:"
                jars.each { jar ->
                    def source = jarToModuleMap[jar] ?: identifyJar(jar)
                    println "     → $jar   [source: $source]"
                }
            }
        } else {
            println "✅ No duplicate classes found"
        }
    }

    /**
     * Attempts to map JAR file paths to local Gradle module names.
     */
    protected Map<File, String> buildJarToModuleMap() {
        def map = [:]
        project.rootProject.subprojects.each { sub ->
            def pathPrefix = new File(sub.buildDir, "intermediates/runtime_library_classes_jar")
            if (pathPrefix.exists()) {
                pathPrefix.eachFileRecurse { f ->
                    if (f.name == "classes.jar") {
                        map[f] = sub.path
                    }
                }
            }
        }
        return map
    }

    /**
     * Fallback classifier for external jars (usually from Gradle caches)
     */
    protected String identifyJar(File jar) {
        if (jar.absolutePath.contains(".gradle/caches/")) {
            def fileName = jar.name
            def parent = jar.parentFile?.name
            return "$parent/$fileName".replace("jetified-", "")
        } else {
            return "unknown"
        }
    }
}

androidComponents {
    onVariants(selector().all(), { variant ->
        TaskProvider taskProvider = project.tasks.register(
                "${variant.name}PrintDuplicateClasses", PrintClassesJars.class
        )
        variant.artifacts.forScope(ScopedArtifacts.Scope.ALL)
                .use(taskProvider)
                .toGet(
                        ScopedArtifact.CLASSES.INSTANCE,
                        { it.allJars },
                        { it.allDirectories }
                )
    })
}